# 1.从struct到class

​    C语言中，当单一变量无法完成描述类型的需求时，结构体类型解决了这一问题，关键字struct可以将多个类型打包成一体，形成新的数据类型，这是C语言中的对数据封装，但是，新类型并不包含，对数据的操作，所有的操作都是通过函数传参的方式。

​    而在C++中可以将数据和行为封装到一起，达到数行合一。

​    从封装数据，到封装数据和行为，但是仍然存在问题，C++中引入了class，可以达到，对外提供接口，屏蔽数据，对内开放数据。

​    struct封装的所有行为和数据，均是public的，也就是均可以通过对象直接访问的，class相比于struct引入了成员权限控制机制。

## 1.1 权限控制

​    struct中所有的行为和属性都默认是public，此举也是为了C++兼容C语言，因为C语言中没有权限的概念。

​    C++中的class可以指定行为和属性的访问方式，默认为private，此举要求你必须指定权限，不然没有办法外部访问。

| 访问属性  | 属性 | 对象内部 | 对象外部 |
| :-------: | :--: | :------: | :------: |
|  public   | 公有 |  可访问  |  可访问  |
|  private  | 私有 |  可访问  | 不可访问 |
| protected | 保护 |  可访问  | 不可访问 |

## 1.2 类外成员函数

​    如何只在类内声明，而实现在类外。注意，相比于以前我们写过的普通全局函数多了类名空间的标识。

```cpp
class Stack
{
public:
    void init();
    bool isEmpty;
    bool isFull;
private:
    int space[1024];
    int top;
};

void Stack::init()
{
    memset(space,0,sizeof(space));
    top = 0;
}

bool Stack::isEmpty()
{
    return top == 0;
}

bool Stack::isFull()
{
    return top == 1024;
}
```

​    ::域运算符，常见于命名空间，此时也用在了类的成员函数上，意指类名也是一个小的作用域命名空间，其作用域内包装了全局成员与函数。

​    声明和实现分开以后，我们就可以将其分文件来写，将声明部分放到.h文件，实现部分放到.cpp文件。

# 2.构造器（Constructor）

## 2.1 语法

```cpp
class 类名
{
    类名(形式参数)
    {
        构造体
    }
};
```

```cpp
class A
{
    A(){}
};
```

## 2.2 构造特性

1. 与类名同，在对象创建时自动调用，完成初始化相关工作。
2. 无返回值，可带参数，可以重载，可默认参数。
3. 系统提供默认无参空实现体，一经自实现构造器，系统提供的默认将不复存在。

## 2.3 关于重载与默认

​    无论通过重载还是默认参数的构造器，一经实现，默认的无参构造器，不复存在。

​    默认无参构造器，常作为生成类对象的一种“标配”存在，所以我们在实现重载或默认参数的构造器的时候，将默认无参构造函数，纳入其中。

## 2.4 初始化列表

​    C++提供了一种，不在构造体内初始化的方法，称为：初始化参数列表。一方面，提升了效率，另一方面是功能的扩展。

​    初始化参数列表位于构造器声明与实现之间，“:”开始，各初始化成员用“,”分开，其后的初始化成员置于“()”内。

```cpp
class Stack
{
public:
    Stack(int size = 10)
        :top(0),_size(size),space(new int[size]{0})
    {}
private:
    int top;
    int _size;
    int *space;
};
```

​    **类成员初始化的顺序与初始化参数列表的顺序无关，与其声明的顺序有关**。此列表中不要拿被初始化成员去初始化其他。

# 3.析构器

## 3.1 语法

```cpp
class 类名
{
    ~类名()
        析构体
}
```

```cpp
class A
{
    ~A()
    {}
}
```

## 3.2 析构特性

1. 对象销毁时，自动调用，完成销毁的善后工作。
2. 无返值，与类名相同，无参，不可以重载与默认参数。
3. 系统提供默认的空析构器，一经自实现，不复存在。

```cpp
~Stack()
{
    delete[] _space;
}
```

# 4.拷贝构造器

​    由普通数值作参数完成构造，为constructor；由同类对象作参数完成构造，为copy constructor。

## 4.1 语法

```cpp
class 类名
{
    类名(const 类名 & another)
        拷贝构造体
}
```

```cpp
class A
{
    A(const A & another)
    {}
}
```

## 4.2 拷贝构造特性

1. 系统提供默认的拷贝构造器。一经实现，不复存在。
2. 系统提供的是等位拷贝，也就是所谓的“浅浅”的拷贝。
3. 要实现深拷贝，必须自定义。
4. 发生时机：制作对象的副本，以对象作为参数和返回值。

## 4.3 浅(shallow) / 深(deep)拷贝

​    系统提供默认的拷贝构造器，一经定义不再提供。但系统提供的默认拷贝构造器是等位拷贝，也就是通常意义上的浅(shallow)拷贝。

​    如果类中包含的数据元素全部在栈上，浅拷贝也可以满足需求的。但如果堆上的数据，则会发生多次析构行为。

# 5.this指针

## 5.1 指向调用对象的指针

​    系统在创建对象时，默认生成**指向当前对象**的指针。

## 5.2 this指针特性

1. 指向当前对象，可用于所有的成员函数，但不能应用于初始化列表。
2. this是以隐式传参的形式传入，而非成员的一部分，所以不会影响sizeof(obj)的大小。
3. this指针本身是不能更改指向的，即，是const类型修饰的。

## 5.3 this指针的作用

1. 指向当前对象，避免入参与成员名相同
2. 支持基于返回this引用的多重串联调用的函数（如连续赋值）。

```cpp
#include <iostream>
using namespace std;
class Stu
{ 
public:
    Stu(string name, int age)
    {
        //name = name;
        //age = age;
        this->name = name;
        this->age = age;
    }
    Stu & growUp()
    {
        this->age++;
        return *this; // return this; ??
    } 
    void display()
    {
        cout<<name<<" : "<<age<<endl;
    }
private:
    string name;
    int age;
};
int main()
{
    Stu s("JIAN",18);
    s.display();
    s.growUp().growUp().growUp().growUp().growUp();
    s.display();
    return 0;
}
```

# 6.赋值运算符重载

​    用一个已有对象，给另一个已有对象赋值。两个对象均已创建结束后，发生的赋值行为，就会涉及到赋值运算符重载的问题。

## 6.1 语法

```cpp
类名
{
    类名& operator=(const 类名& 源对象)
        拷贝体
}
```

```cpp
class A
{
    A& operator=(const A& another)
    {
        //函数体
        return *this;
    }
};
```

## 6.2 特性

1. 系统提供默认的赋值运算符重载，一经自实现，不复存在。
2. 系统提供的也是等位拷贝，也就是浅拷贝，会造成内存泄漏，重析构。
3. 要实现深赋值，必须自定义。
4. 自实现需要解决3个问题：重析构，内存泄漏，自赋值。
5. 返回引用，通常不能用const修饰。

# 7.栈对象返回问题

```cpp
class A
{
public:
    A()
    {
        cout<<this<<"  constructor"<<endl;
    }
    A(const A & another)
    {
        cout<<this<<"  cp constructor from "<<&another<<endl;
    }
    A & operator=(const A & another)
    {
        cout<<this<<"  operator = "<<&another<<endl;
        return *this;
    }
    ~A()
    {
        cout<<this<<"  destructor"<<endl;
    }
};
```

```cpp
//void foo(A a)
void foo(A &a)
{

}

int main()
{
    A a;
    foo(a);
    return 0;
}
```

​    传值会发生一次构造，一次拷贝，两次析构；传引用，会发生一次构造，一次析构。所以传引用的效率更高。

​    （具名）返回值优化（(Name)Return Value Optimization，简称(N)RVO），是这么一种优化机制：当函数需要返回一个对象的时候，如果自己创建一个临时对象用户返回，那么这个临时对象会消耗一个构造函数的调用、一个拷贝构造函数的调用以及一个析构函数的调用的代价。通过优化的方式可以减少这些开销。

​     可以返回栈对象（不同平台有不同的优化），不可以返回栈对象的引用。

# 8.对象数组

​    如果生成的数组，未初始化，则必调用无参构造器，或手动调用带参构造器。构造器无论是重载还是默认参数，尽量把系统默认的无参构造器包含进来。不然生成数组的时候，可能会有些麻烦。

​    在对象数组中，要求对象必须包含无参构造器的情况，但有时，默认无参构造器并不能满足我们的需求，可能要再次初始化。二段初始化，常将默认无参构造器置空。然后再次调用初始化函数。